<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.LanguageServer.Protocol</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Extensions.GetUriForRenamedDocument(Microsoft.CodeAnalysis.TextDocument)">
            <summary>
            Generate the Uri of a document by replace the name in file path using the document's name.
            Used to generate the correct Uri when rename a document, because calling <seealso cref="M:Microsoft.CodeAnalysis.Document.WithName(System.String)"/> doesn't update the file path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.ProtocolConversions.RoslynTagToCompletionItemKinds">
            <summary>
            Mapping from tags to lsp completion item kinds.  The value lists the potential lsp kinds from
            least-preferred to most preferred.  More preferred kinds will be chosen if the client states they support
            it.  This mapping allows values including extensions to the kinds defined by VS (but not in the core LSP
            spec).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.ProtocolConversions.CreateAbsoluteUri(System.String)">
            <summary>
            Converts an absolute local file path or an absolute URL string to <see cref="T:System.Uri"/>.
            </summary>
            <exception cref="T:System.UriFormatException">
            The <paramref name="absolutePath"/> can't be represented as <see cref="T:System.Uri"/>.
            For example, UNC paths with invalid characters in server name.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.ProtocolConversions.ChangedDocumentsToTextDocumentEditsAsync``1(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},System.Func{Microsoft.CodeAnalysis.DocumentId,``0},System.Func{Microsoft.CodeAnalysis.DocumentId,``0},Microsoft.CodeAnalysis.IDocumentTextDifferencingService,System.Threading.CancellationToken)">
            <summary>
            Compute all the <see cref="T:Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentEdit"/> for the input list of changed documents.
            Additionally maps the locations of the changed documents if necessary.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.HostWorkspace.LanguageServerProjectSystemOptionsStorage.BinaryLogPath">
            <summary>
            A folder to log binlogs to when running design-time builds.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.HostWorkspace.LanguageServerProjectSystemOptionsStorage.EnableAutomaticRestore">
            <summary>
            Whether or not automatic nuget restore is enabled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1">
            <summary>
            Helper type to allow command handlers to report data either in a streaming fashion (if a client supports that),
            or as an array of results.  This type is thread-safe in the same manner that <see cref="T:System.IProgress`1"/> is
            expected to be.  Namely, multiple client can be calling <see cref="M:System.IProgress`1.Report(`0)"/> on it at the same
            time.  This is safe, though the order that the items are reported in when called concurrently is not specified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1._underlyingProgress">
            <summary>
            The progress stream to report results to.  May be <see langword="null"/> for clients that do not support streaming.
            If <see langword="null"/> then <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1._buffer"/> will be non null and will contain all the produced values.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1._buffer">
            <summary>
            A buffer that results are held in if the client does not support streaming.  Values of this can be retrieved
            using <see cref="M:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1.GetValues"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1.Report(`0)">
            <summary>
            Report a value either in a streaming or buffered fashion depending on what the client supports.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1.GetValues">
            <summary>
            Gets the set of buffered values.  Will return null if the client supports streaming.  Must be called after
            all calls to <see cref="M:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1.Report(`0)"/> have been made.  Not safe to call concurrently with any call to <see
            cref="M:Microsoft.CodeAnalysis.LanguageServer.Handler.BufferedProgress`1.Report(`0)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActions.CodeActionHelpers.GetVSCodeActionsAsync(Microsoft.VisualStudio.LanguageServer.Protocol.CodeActionParams,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,Microsoft.CodeAnalysis.CodeFixes.ICodeFixService,Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get, order, and filter code actions, and then transform them into VSCodeActions or CodeActions based on <paramref name="hasVsLspCapability"/>.
            </summary>
            <remarks>
            Used by CodeActionsHandler.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActions.CodeActionHelpers.GenerateCodeActions(Microsoft.VisualStudio.LanguageServer.Protocol.CodeActionParams,Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction,Microsoft.VisualStudio.LanguageServer.Protocol.CodeActionKind)">
            <summary>
            Generate the matching code actions for <paramref name="suggestedAction"/>. If it contains nested code actions, flatten them into an array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActions.CodeActionHelpers.GetCodeActionsAsync(Microsoft.CodeAnalysis.Document,Microsoft.VisualStudio.LanguageServer.Protocol.Range,Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,Microsoft.CodeAnalysis.CodeFixes.ICodeFixService,Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService,System.String,System.Threading.CancellationToken)">
            <summary>
            Get, order, and filter code actions.
            </summary>
            <remarks>
            Used by CodeActionResolveHandler and RunCodeActionHandler.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActions.CodeActionHelpers.GetNestedActionsFromActionSet(Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction,System.String)">
            <summary>
            Generates a code action with its nested actions properly set.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActions.CodeActionResolveData">
            <summary>
            This class provides the intermediate data passed between CodeActionsHandler, CodeActionResolveHandler,
            and RunCodeActionsHandler. The class provides enough information for each handler to identify the code
            action that it is dealing with. The information is passed along via the Data property in LSP.VSCodeAction. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActions.CodeActionResolveData.UniqueIdentifier">
            <summary>
            The unique identifier of a code action. No two code actions should have the same unique identifier.
            </summary>
            <remarks>
            The unique identifier is currently set as:
            name of top level code action + '|' + name of nested code action + '|' + name of nested nested code action + etc.
            e.g. 'Suppress or Configure issues|Suppress IDEXXXX|in Source'
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActionResolveHandler">
            <summary>
            Resolves a code action by filling out its Edit property. The handler is triggered only when a user hovers over a
            code action. This system allows the basic code action data to be computed quickly, and the complex data, to be
            computed only when necessary (i.e. when hovering/previewing a code action).
            <para>
            This system only supports text edits to documents.  In the future, supporting complex edits (including changes to
            project files) would be desirable.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeActionsHandler">
            <summary>
            Handles the initial request for code actions. Leaves the Edit and Command properties of the returned
            VSCodeActions blank, as these properties should be populated by the CodeActionsResolveHandler only when the user
            requests them.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeLens.CodeLensResolveData">
            <summary>
            Datatype storing the information needed to resolve a particular code lens item.
            </summary>
            <param name="SyntaxVersion">the syntax version of the text document.</param>
            <param name="ListIndex">the index of the specific code lens item in the original list.</param>
            <param name="TextDocument">the text document associated with the code lens to resolve.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeLens.CodeLensResolveData.#ctor(System.String,System.Int32,Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier)">
            <summary>
            Datatype storing the information needed to resolve a particular code lens item.
            </summary>
            <param name="SyntaxVersion">the syntax version of the text document.</param>
            <param name="ListIndex">the index of the specific code lens item in the original list.</param>
            <param name="TextDocument">the text document associated with the code lens to resolve.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeLens.CodeLensResolveData.SyntaxVersion">
            <summary>the syntax version of the text document.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeLens.CodeLensResolveData.ListIndex">
            <summary>the index of the specific code lens item in the original list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeLens.CodeLensResolveData.TextDocument">
            <summary>the text document associated with the code lens to resolve.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.CodeLens.CodeLensResolveHandler.ClientReferencesCommand">
            <summary>
            Command name implemented by the client and invoked when the references code lens is selected.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Completion.CompletionListCache">
            <summary>
            Caches completion lists in between calls to CompletionHandler and
            CompletionResolveHandler. Used to avoid unnecessary recomputation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Completion.CompletionResolveData">
            <summary>
            Provides the intermediate data passed from CompletionHandler to CompletionResolveHandler.
            Passed along via <see cref="P:Microsoft.VisualStudio.LanguageServer.Protocol.CompletionItem.Data"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.Completion.CompletionResolveData.ResultId">
            <summary>
            ID associated with the item's completion list.
            </summary>
            <remarks>
            Used to retrieve the correct completion list from <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Completion.CompletionListCache"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Completion.DefaultLspCompletionResultCreationService.CompleteComplexEditCommand">
            <summary>
            Command name implemented by the client and invoked when an item with complex edit is committed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.CompletionHandler">
            <summary>
            Handle a completion request.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.CompletionResolveHandler">
            <summary>
            Handle a completion resolve request to add description.
            </summary>
            <remarks>
            This isn't a <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.ILspServiceDocumentRequestHandler`2" /> because it could return null.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Configuration.DidChangeConfigurationNotificationHandler._configurationItems">
            <summary>
            All the <see cref="P:Microsoft.VisualStudio.LanguageServer.Protocol.ConfigurationItem.Section"/> needs to be refreshed from the client. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Configuration.DidChangeConfigurationNotificationHandler._optionsAndLanguageNamesToRefresh">
            <summary>
            The matching option and its language name needs to be refreshed. The order matches <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Configuration.DidChangeConfigurationNotificationHandler._configurationItems"/> sent to the client.
            LanguageName would be null if the option is <see cref="T:Microsoft.CodeAnalysis.Options.ISingleValuedOption"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Configuration.DidChangeConfigurationNotificationHandler.GenerateGlobalConfigurationItems">
            <summary>
            Generate the configuration items send to the client.
            For each option, generate its full name. If the option is <see cref="T:Microsoft.CodeAnalysis.Options.ISingleValuedOption"/> it's is what we sent to the client.
            If it is <see cref="T:Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption"/>, then generate two configurationItems with prefix visual_basic and csharp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Configuration.DidChangeConfigurationNotificationHandler.GenerateFullNameForOption(Microsoft.CodeAnalysis.Options.IOption2)">
            <summary>
            Generate the full name of <param name="option"/>.
            It would be in the format like {optionGroupName}.{OptionName}
            </summary>
            <remarks>
            Example:Full name of <see cref="F:Microsoft.CodeAnalysis.ImplementType.ImplementTypeOptionsStorage.InsertionBehavior"/> would be:
            implement_type.dotnet_insertion_behavior
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3">
            <summary>
            Root type for both document and workspace diagnostic pull requests.
            </summary>
            <typeparam name="TDiagnosticsParams">The LSP input param type</typeparam>
            <typeparam name="TReport">The LSP type that is reported via IProgress</typeparam>
            <typeparam name="TReturn">The LSP type that is returned on completion of the request.</typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.WorkspaceDiagnosticIdentifier">
            <summary>
            Special value we use to designate workspace diagnostics vs document diagnostics.  Document diagnostics
            should always <see cref="P:Microsoft.VisualStudio.LanguageServer.Protocol.VSInternalDiagnosticReport.Supersedes"/> a workspace diagnostic as the former are 'live'
            while the latter are cached and may be stale.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3._categoryToVersionedCache">
            <summary>
            Cache where we store the data produced by prior requests so that they can be returned if nothing of significance 
            changed. The <see cref="T:Microsoft.CodeAnalysis.VersionStamp"/> is produced by <see cref="M:Microsoft.CodeAnalysis.Project.GetDependentVersionAsync(System.Threading.CancellationToken)"/> while the 
            <see cref="T:Microsoft.CodeAnalysis.Checksum"/> is produced by <see cref="M:Microsoft.CodeAnalysis.Project.GetDependentChecksumAsync(System.Threading.CancellationToken)"/>.  The former is faster
            and works well for us in the normal case.  The latter still allows us to reuse diagnostics when changes happen that
            update the version stamp but not the content (for example, forking LSP text).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.GetPreviousResults(`0)">
            <summary>
            Retrieve the previous results we reported.  Used so we can avoid resending data for unchanged files. Also
            used so we can report which documents were removed and can have all their diagnostics cleared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.GetOrderedDiagnosticSourcesAsync(`0,Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext,System.Threading.CancellationToken)">
            <summary>
            Returns all the documents that should be processed in the desired order to process them in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.CreateReport(Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier,Microsoft.VisualStudio.LanguageServer.Protocol.Diagnostic[],System.String)">
            <summary>
            Creates the appropriate LSP type to report a new set of diagnostics and resultId.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.CreateUnchangedReport(Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier,System.String)">
            <summary>
            Creates the appropriate LSP type to report unchanged diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.CreateRemovedReport(Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier)">
            <summary>
            Creates the appropriate LSP type to report a removed file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.ConvertTags(Microsoft.CodeAnalysis.Diagnostics.DiagnosticData,System.Boolean)">
            <summary>
            Generate the right diagnostic tags for a particular diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.WaitForChangesAsync(Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext,System.Threading.CancellationToken)">
            <summary>
            Used by public workspace pull diagnostics to allow it to keep the connection open until
            changes occur to avoid the client spamming the server with requests.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3.ConvertTags(Microsoft.CodeAnalysis.Diagnostics.DiagnosticData,System.Boolean,System.Boolean)">
            <summary>
            If you make change in this method, please also update the corresponding file in
            src\VisualStudio\Xaml\Impl\Implementation\LanguageServer\Handler\Diagnostics\AbstractPullDiagnosticHandler.cs
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractWorkspacePullDiagnosticsHandler`3._lspChanged">
            <summary>
            Flag that represents whether the LSP view of the world has changed.
            It is totally fine for this to somewhat over-report changes
            as it is an optimization used to delay closing workspace diagnostic requests
            until something has changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractProjectDiagnosticSource.FullSolutionAnalysisDiagnosticSource.IsLiveSource">
            <summary>
            This is a normal project source that represents live/fresh diagnostics that should supersede everything else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractProjectDiagnosticSource.CodeAnalysisDiagnosticSource.IsLiveSource">
            <summary>
            This source provides the results of the *last* explicitly kicked off "run code analysis" command from the
            user.  As such, it is definitely not "live" data, and it should be overridden by any subsequent fresh data
            that has been produced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractWorkspaceDocumentDiagnosticSource.FullSolutionAnalysisDiagnosticSource.IsLiveSource">
            <summary>
            This is a normal document source that represents live/fresh diagnostics that should supersede everything else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractWorkspaceDocumentDiagnosticSource.CodeAnalysisDiagnosticSource.IsLiveSource">
            <summary>
            This source provides the results of the *last* explicitly kicked off "run code analysis" command from the
            user.  As such, it is definitely not "live" data, and it should be overridden by any subsequent fresh data
            that has been produced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.DocumentDiagnosticSource.IsLiveSource">
            <summary>
            This is a normal document source that represents live/fresh diagnostics that should supersede everything else.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.IDiagnosticSource">
            <summary>
            Wrapper around a source for diagnostics (e.g. a <see cref="T:Microsoft.CodeAnalysis.Project"/> or <see cref="T:Microsoft.CodeAnalysis.Document"/>)
            so that we can share per file diagnostic reporting code in <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.AbstractPullDiagnosticHandler`3"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.IDiagnosticSource.IsLiveSource">
            <summary>
            True if this source produces diagnostics that are considered 'live' or not.  Live errors represent up to date
            information that should supersede other sources.  Non 'live' errors (aka "build errors") are recognized to
            potentially represent stale results from a point in the past when the computation occurred.  The only time
            Roslyn produces non-live errors through an explicit user gesture to "run code analysis". Because these represent
            errors from the past, we do want them to be superseded by a more recent live run, or a more recent build from
            another source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.DiagnosticsRefreshQueue.Refresher._globalStateVersion">
            <summary>
            Incremented every time a refresh is requested.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.ProjectOrDocumentId">
            <summary>
            Wrapper around project and document ids for convenience in caching diagnostic results and
            use in the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.IDiagnosticSource"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.ProjectOrDocumentId._documentId">
            <summary>
            Non-null if this represents a documentId.  Used for equality comparisons.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.ProjectOrDocumentId._projectId">
            <summary>
            Non-null if this represents a projectId.  Used for equality comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.Public.PublicDocumentPullDiagnosticsHandler.GetDiagnosticCategory(Microsoft.VisualStudio.LanguageServer.Protocol.DocumentDiagnosticParams)">
            <summary>
            Public API doesn't support categories (yet).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.Public.PublicWorkspacePullDiagnosticsHandler.GetDiagnosticCategory(Microsoft.VisualStudio.LanguageServer.Protocol.WorkspaceDiagnosticParams)">
            <summary>
            Public API doesn't support categories (yet).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.PullDiagnosticCategories.Task">
            <summary>
            Task list items.  Can be for Document or Workspace pull requests.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.PullDiagnosticCategories.WorkspaceDocumentsAndProject">
            <summary>
            Diagnostics for workspace documents and project.  We don't support fine-grained diagnostics requests for these (yet).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.FoldingRangesHandler.GetFoldingRangesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Structure.BlockStructureOptions,System.Threading.CancellationToken)">
            <summary>
            Used here and by lsif generator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.HoverHandler">
            <summary>
            TODO - This must be moved to the MS.CA.LanguageServer.Protocol project once it
            no longer references VS icon or classified text run types.
            See https://github.com/dotnet/roslyn/issues/55142
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.IDocumentChangeTracker">
            <summary>
            Associates LSP document URIs with the roslyn source text containing the LSP document text.
            Called via <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidOpenHandler"/>, <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidChangeHandler"/> and <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidCloseHandler"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.ILspServiceRequestHandler`2">
            <summary>
            Handler for a workspace request with parameters <typeparamref name="TRequest"/> and result <typeparamref name="TResponse"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.ILspServiceRequestHandler`1">
            <summary>
            Handler for a workspace parameter-less request with result <typeparamref name="TResponse"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.ILspServiceDocumentRequestHandler`2">
            <summary>
            Handler for document request with parameters <typeparamref name="TRequest"/> and result <typeparamref name="TResponse"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintCache.InlayHintCacheEntry">
            <summary>
            Cached data need to resolve a specific inlay hint item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintCache.InlayHintCacheEntry.#ctor(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.InlineHints.InlineHint},Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            Cached data need to resolve a specific inlay hint item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintHandler.Trim(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TaggedText})">
            <summary>
            Goes through the tagged text of the hint and trims off leading and trailing spaces. 
            If there is leading or trailing space, then we want to add padding to the left and right accordingly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintResolveData">
            <summary>
            Datatype storing the information needed to resolve a particular inlay hint item.
            </summary>
            <param name="ResultId">the resultId associated with the inlay hint created on original request.</param>
            <param name="ListIndex">the index of the specific inlay hint item in the original list.</param>
            /// <param name="TextDocument">the text document associated with the inlay hint to resolve.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintResolveData.#ctor(System.Int64,System.Int32,Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier)">
            <summary>
            Datatype storing the information needed to resolve a particular inlay hint item.
            </summary>
            <param name="ResultId">the resultId associated with the inlay hint created on original request.</param>
            <param name="ListIndex">the index of the specific inlay hint item in the original list.</param>
            /// <param name="TextDocument">the text document associated with the inlay hint to resolve.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintResolveData.ResultId">
            <summary>the resultId associated with the inlay hint created on original request.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintResolveData.ListIndex">
            <summary>the index of the specific inlay hint item in the original list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.InlayHint.InlayHintResolveData.TextDocument">
            /// <summary>the text document associated with the inlay hint to resolve.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.InlineCompletionsHandler">
            <summary>
            Supports built in legacy snippets for razor scenarios.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.InlineCompletionsHandler.BuiltInSnippets">
            <summary>
            The set of built in snippets from, typically found in
            C:\Program Files\Microsoft Visual Studio\2022\VS_INSTANCE\VC#\Snippets\1033\Visual C#
            These are currently the only snippets supported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.InlineCompletionsHandler.GetFormattedLspSnippetAsync(Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.ParsedXmlSnippet,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions,Microsoft.CodeAnalysis.Simplification.SimplifierOptions,System.Threading.CancellationToken)">
            <summary>
            Formats the snippet by applying the snippet to the document with the default values / function results for snippet declarations.
            Then converts back into an LSP snippet by replacing the declarations with the appropriate LSP tab stops.
            
            Note that the operations in this method are sensitive to the context in the document and so must be calculated on each request.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.InlineCompletionsHandler.GetReplacedSnippetTextAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.ParsedXmlSnippet,Microsoft.CodeAnalysis.Simplification.SimplifierOptions,System.Threading.CancellationToken)">
            <summary>
            Create the snippet with the full default text and functions applied.  Output the spans associated with
            each field and the final caret location in that text so that we can find those locations later.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser">
            <summary>
            Server instance agnostic snippet parser and cache.
            This can be re-used across LSP servers as we're just storing an
            internal representation of an XML snippet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.CodeSnippet">
            <summary>
            Shamelessly copied from the editor
            https://devdiv.visualstudio.com/DevDiv/_git/VS-Platform?path=/src/Editor/VisualStudio/Impl/Snippet/CodeSnippet.cs
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.CodeSnippet.#ctor(System.Xml.Linq.XElement)">
            <summary>
            Ctor.
            </summary>
            <param name="codeSnippetElement">XElement representing the CodeSnippet node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.CodeSnippet.ReadSnippets(System.Xml.Linq.XDocument)">
            <summary>
            Visible for testing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.ExpansionTemplate">
            <summary>
            Shamelessly adapted from https://devdiv.visualstudio.com/DevDiv/_git/VS-Platform?path=/src/Editor/VisualStudio/Impl/Snippet/ExpansionTemplate.cs
            with changes to parsing to store the snippet as a set of parts instead of a single string.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser._parsedSnippetsCache">
            <summary>
            Cache to hold onto the parsed XML for a particular snippet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.SnippetCursorPart">
            <summary>
            To indicate cursor location we put in a multi-line comment so that we can
            find it after formatting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.InlineCompletions.XmlSnippetParser.SnippetCursorPart.#ctor">
            <summary>
            To indicate cursor location we put in a multi-line comment so that we can
            find it after formatting.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.LspErrorCodes">
            <summary>
            See https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#errorCodes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.LspErrorCodes.ContentModified">
            <summary>
            Signals that the server detected the contents of the document were modified
            outside of normal conditions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`1">
            <summary>
            Simplified version of <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2"/> that only uses a 
            single cheap key to check results against.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2">
            <summary>
            Specialized cache used by the 'pull' LSP handlers.  Supports storing data to know when to tell a client
            that existing results can be reused, or if new results need to be computed.  Multiple keys can be used,
            with different computation costs to determine if the previous cached data is still valid.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2._semaphore">
            <summary>
            Lock to protect <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2._idToLastReportedResult"/> and <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2._nextDocumentResultId"/>.
            This enables this type to be used by request handlers that process requests concurrently.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2._idToLastReportedResult">
            <summary>
            Mapping of a diagnostic source to the data used to make the last pull report which contains:
            <list type="bullet">
              <item>The resultId reported to the client.</item>
              <item>The TCheapVersion of the data that was used to calculate results.
                  <para>
                  Note that this version can change even when nothing has actually changed (for example, forking the 
                  LSP text, reloading the same project). So we additionally store:</para></item>
              <item>A TExpensiveVersion (normally a checksum) checksum that will still allow us to reuse data even when
              unimportant changes happen that trigger the cheap version change detection.</item>
            </list>
            This is used to determine if we need to re-calculate results.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2._nextDocumentResultId">
            <summary>
            The next available id to label results with.  Note that results are tagged on a per-document bases.  That
            way we can update results with the client with per-doc granularity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.VersionedPullCache`2.GetNewResultIdAsync(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.ProjectOrDocumentId,Microsoft.CodeAnalysis.LanguageServer.Handler.PreviousPullResult},Microsoft.CodeAnalysis.LanguageServer.Handler.Diagnostics.ProjectOrDocumentId,Microsoft.CodeAnalysis.Project,System.Func{System.Threading.Tasks.Task{`0}},System.Func{System.Threading.Tasks.Task{`1}},System.Threading.CancellationToken)">
            <summary>
            If results have changed since the last request this calculates and returns a new
            non-null resultId to use for subsequent computation and caches it.
            </summary>
            <param name="idToClientLastResult">a map of roslyn document or project id to the previous result the client sent us for that doc.</param>
            <param name="projectOrDocumentId">the id of the project or document that we are checking to see if it has changed.</param>
            <returns>Null when results are unchanged, otherwise returns a non-null new resultId.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.FindUsagesLSPContext._semaphore">
            <summary>
            Methods in FindUsagesLSPContext can be called by multiple threads concurrently. We need this semaphore to
            ensure that we aren't making concurrent modifications to data such as _id and _definitionToId.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.FindUsagesLSPContext._definitionsWithoutReference">
            <summary>
            Keeps track of definitions that cannot be reported without references and which we have
            not yet found a reference for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.FindUsagesLSPContext._referenceLocations">
            <summary>
            Set of the locations we've found references at.  We may end up with multiple references
            being reported for the same location.  For example, this can happen in multi-targeting 
            scenarios when there are symbols in files linked into multiple projects.  Those symbols
            may have references that themselves are in linked locations, leading to multiple references
            found at different virtual locations that the user considers at the same physical location.
            For now we filter out these duplicates to not clutter the UI.  If LSP supports the ability
            to override an already reported VSReferenceItem, we could also reissue the item with the
            additional information about all the projects it is found in.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.FindUsagesLSPContext._workQueue">
            <summary>
            We report the results in chunks. A batch, if it contains results, is reported every 0.5s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext">
            <summary>
            Context for requests handled by <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.IMethodHandler"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext._documentChangeTracker">
            <summary>
            This will be the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.NonMutatingDocumentChangeTracker"/> for non-mutating requests because they're not allowed to change documents
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext._clientCapabilities">
            <summary>
            The client capabilities for the request.
            </summary>
            <remarks>
            Should only be null on the "initialize" request.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext._trackedDocuments">
            <summary>
            Contains the LSP text for all opened LSP documents from when this request was processed in the queue.
            </summary>
            <remarks>
            This is a snapshot of the source text that reflects the LSP text based on the order of this request in the queue.
            It contains text that is consistent with all prior LSP text sync notifications, but LSP text sync requests
            which are ordered after this one in the queue are not reflected here.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext._lspSolution">
            <summary>
            Provides backing storage for the LSP workspace used by this RequestContext instance, allowing it to be cleared
            on demand from all copies that may exist of this value type.
            </summary>
            <remarks>
            This field is only initialized for handlers that request solution context.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.Workspace">
            <summary>
            The workspace this request is for, if applicable.  This will be present if <see cref="P:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.Document"/> is
            present.  It will be <see langword="null"/> if <c>requiresLSPSolution</c> is false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.Solution">
            <summary>
            The solution state that the request should operate on, if the handler requires an LSP solution, or <see langword="null"/> otherwise
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.Document">
            <summary>
            The document that the request is for, if applicable. This comes from the <see cref="T:Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier"/> returned from the handler itself via a call to 
            <see cref="M:Microsoft.CommonLanguageServerProtocol.Framework.ITextDocumentIdentifierHandler`2.GetTextDocumentIdentifier(`0)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.ServerKind">
            <summary>
            The LSP server handling the request.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.Method">
            <summary>
            The method this request is targeting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.SupportedLanguages">
            <summary>
            The languages supported by the server making the request.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext._logger">
            <summary>
            Tracing object that can be used to log information about the status of requests.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.StartTrackingAsync(System.Uri,Microsoft.CodeAnalysis.Text.SourceText,System.String,System.Threading.CancellationToken)">
            <summary>
            Allows a mutating request to open a document and start it being tracked.
            Mutating requests are serialized by the execution queue in order to prevent concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.UpdateTrackedDocument(System.Uri,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Allows a mutating request to update the contents of a tracked document.
            Mutating requests are serialized by the execution queue in order to prevent concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.StopTrackingAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Allows a mutating request to close a document and stop it being tracked.
            Mutating requests are serialized by the execution queue in order to prevent concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext.TraceInformation(System.String)">
            <summary>
            Logs an informational message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestTelemetryLogger">
            <summary>
            Logs metadata on LSP requests (duration, success / failure metrics)
            for this particular LSP server instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestTelemetryLogger._queuedDurationLogAggregator">
            <summary>
            Histogram to aggregate the time in queue metrics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestTelemetryLogger._requestDurationLogAggregator">
            <summary>
            Histogram to aggregate total request duration metrics.
            This histogram is log based as request latencies can be highly variable depending
            on the request being handled.  As such, we apply the log based function
            defined by ComputeLogValue to the request latencies for storing in the histogram.
            This provides highly detailed buckets when duration is in MS, but less detailed
            when the duration is in terms of seconds or minutes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestTelemetryLogger._requestCounters">
            <summary>
            Store request counters in a concurrent dictionary as non-mutating LSP requests can
            run alongside other non-mutating requests.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestTelemetryLogger.ComputeLogValue(System.Double)">
            <summary>
            Given an input duration in MS, this transforms it using
            the log function below to put in reasonable log based buckets
            from 50ms to 1 hour.  Similar transformations must be done to read
            the data from kusto.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestTelemetryLogger.Dispose">
            <summary>
            Only output aggregate telemetry to the vs logger when the server instance is disposed
            to avoid spamming the telemetry output with thousands of events
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1">
             <summary>
             A common LSP pattern is an initial request to the server that returns some set of partially filled out items.
             Then the client issues a xyz/resolve request to fully resolve a specific item when actually needed.
             
             On the server side we often need to cache non-serializable data that can't be included in the typical
             'data' field on the actual item.  This type is a general cache that helps keep track of data between requests.
            
             This cache is generally only written to as part of the initial request to store data for later resolution.
             It is only read from as part of a resolve request for some data sent in the initial request to restore state.
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1._maxCacheSize">
            <summary>
            Maximum number of cache entries allowed in cache. Must be >= 1.
            Typically a resolve request will only ask about the most recent cache entry so
            it is not important to cache a lot of entries.  If there are document changes
            the client is responsible for not asking to resolve invalid items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1._accessLock">
            <summary>
            Multiple cache requests or updates may be received concurrently.
            We need this lock to ensure that we aren't making concurrent
            modifications to <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1._nextResultId"/> or <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1._resultIdToCachedItem"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1._nextResultId">
            <summary>
            The next resultId available to use.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1._resultIdToCachedItem">
            <summary>
            Keeps track of the resultIds in the cache and their associated cache entry.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1.UpdateCache(`0)">
            <summary>
            Adds a completion list to the cache. If the cache reaches its maximum size, the oldest completion
            list in the cache is removed.
            </summary>
            <returns>
            The generated resultId associated with the passed in completion list.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.ResolveCache`1.GetCachedEntry(System.Int64)">
            <summary>
            Attempts to return the completion list in the cache associated with the given resultId.
            Returns null if no match is found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.CustomLspSemanticTokenNames">
            <summary>
            Maps <see cref="T:Microsoft.CodeAnalysis.Classification.ClassificationTypeNames"/> to LSP compatible semantic token names.
            Since these token names are effectively a public contract that users can directly interact with,
            we need these names to be nicely formatted and compatible with LSP client rules.
            All classification names must be explicitly mapped to an LSP semantic token type or
            a custom token type name defined here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensHelpers.ComputeSemanticTokensDataAsync(Microsoft.VisualStudio.LanguageServer.Protocol.ClientCapabilities,Microsoft.CodeAnalysis.Document,Microsoft.VisualStudio.LanguageServer.Protocol.Range[],Microsoft.CodeAnalysis.Classification.ClassificationOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the semantic tokens data for a given document with an optional ranges.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensRefreshQueue">
            <summary>
            Batches requests to refresh the semantic tokens to optomize user experience.
            </summary>
            <remarks>This implements <see cref="T:Microsoft.CodeAnalysis.LanguageServer.IOnInitialized"/> to avoid race conditions
            related to creating the queue on the first request.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensRefreshQueue._gate">
            <summary>
            Lock over the mutable state that follows.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensRefreshQueue._projectIdToEventSource">
            <summary>
            Mapping from project id to the workqueue for producing the corresponding compilation for it on the OOP server.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensRefreshQueue._projectIdToLastComputedChecksum">
            <summary>
            Mapping from project id to the project-cone-checksum for it we were at when the project for it had its
            compilation produced on the oop server.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensRefreshQueue._semanticTokenRefreshQueue">
            <summary>
            Debouncing queue so that we don't attempt to issue a semantic tokens refresh notification too often.
            
            Null when the client does not support sending refresh notifications.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.s_vsDirectTypeMap">
            <summary>
            Core VS classifications, only map a few things to LSP.  The rest we keep as our own standard classification
            type names so those continue to work in VS.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.s_pureLspDirectTypeMap">
            <summary>
            The 'pure' set of classification types maps exact Roslyn matches to the well defined values actually in LSP.
            For example "class name" to "class".  Importantly though, if there is no exact match, we do not map things
            along.  This allows the user to theme things however they want.  
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.s_vsTokenSchema">
            <summary>
            A schema for mapping classification type names to VS LSP token names.  This maps a few classification type names
            directly to LSP semantic token types, but otherwise generally returns the classification type name as a custom token type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.s_pureLspTokenSchema">
            <summary>
            A schema for mapping classification type names to 'pure' LSP token names.  This includes classification type names
            that are directly mapped to LSP semantic token types as well as mappings from roslyn classification type names to
            LSP compatible custom token type names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.TokenTypeMap">
            <summary>
            Mapping from roslyn <see cref="T:Microsoft.CodeAnalysis.Classification.ClassificationTypeNames"/> to the LSP token name.  This is either a standard
            <see cref="T:Microsoft.VisualStudio.LanguageServer.Protocol.SemanticTokenTypes"/> or a custom token name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.TokenTypeToIndex">
            <summary>
            Mapping from the semantic token type name to the index in <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.AllTokenTypes"/>.  Required since we report
            tokens back to LSP as a series of ints, and LSP needs a way to decipher them.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.AllTokenTypes">
            <summary>
            Equivalent to see <see cref="F:Microsoft.VisualStudio.LanguageServer.Protocol.SemanticTokenTypes.AllTypes"/> combined with the remaining custom token names from <see cref="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.SemanticTokensSchema.TokenTypeMap"/> 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.SemanticTokens.TokenModifiers">
            <summary>
            The LSP modifiers from <see cref="T:Microsoft.VisualStudio.LanguageServer.Protocol.SemanticTokenModifiers"/>
            Roslyn currently supports. Enum is used to signify the modifier(s) that apply to a given token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.SignatureHelpHandler.GetSignatureText(Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem)">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem"/> contains a prefix, parameters separated by a
            separator and a suffix. Parameters themselves have a prefix, display and suffix.
            Concatenate them all to get the text.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.SpellCheck.AbstractSpellCheckHandler`2">
            <summary>
            Root type for both document and workspace spell checking requests.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.Handler.SpellCheck.AbstractSpellCheckHandler`2._versionedCache">
            <summary>
            Cache where we store the data produced by prior requests so that they can be returned if nothing of
            significance changed. The version key is produced by combining the checksums for project options <see
            cref="M:Microsoft.CodeAnalysis.ProjectState.GetParseOptionsChecksum"/> and <see cref="P:Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums.Text"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.SpellCheck.AbstractSpellCheckHandler`2.GetPreviousResults(`0)">
            <summary>
            Retrieve the previous results we reported.  Used so we can avoid resending data for unchanged files. Also
            used so we can report which documents were removed and can have all their spell checking results cleared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.SpellCheck.AbstractSpellCheckHandler`2.GetOrderedDocuments(Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext,System.Threading.CancellationToken)">
            <summary>
            Returns all the documents that should be processed in the desired order to process them in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.SpellCheck.AbstractSpellCheckHandler`2.CreateReport(Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier,System.Int32[],System.String)">
            <summary>
            Creates the <see cref="T:Microsoft.VisualStudio.LanguageServer.Protocol.VSInternalSpellCheckableRangeReport"/> instance we'll report back to clients to let them know our
            progress.  Subclasses can fill in data specific to their needs as appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentSymbolsHandler">
            <summary>
            TODO - This must be moved to the MS.CA.LanguageServer.Protocol project once
            we no longer reference VS icon types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentSymbolsHandler.GetSymbolInformation(Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.SourceText,System.String)">
            <summary>
            Get a symbol information from a specified nav bar item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentSymbolsHandler.GetDocumentSymbol(Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem,Microsoft.CodeAnalysis.Text.SourceText,System.Threading.CancellationToken)">
            <summary>
            Get a document symbol from a specified nav bar item.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentSymbolsHandler.GetDocumentSymbolName(System.String)">
            <summary>
            DocumentSymbol name cannot be null or empty. Check if the name is invalid,
            and if so return a substitute string.
            </summary>
            <param name="proposedName">Name proposed for DocumentSymbol</param>
            <returns>Valid name for DocumentSymbol</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.RoslynDocumentSymbol">
            <summary>
            Derived version of <see cref="T:Microsoft.VisualStudio.LanguageServer.Protocol.DocumentSymbol" /> used so we can pass additional information we do not want lost for our
            internal consumers.  For example, the richer <see cref="P:Microsoft.CodeAnalysis.LanguageServer.Handler.RoslynDocumentSymbol.Glyph"/> which is a superset of <see
            cref="P:Microsoft.VisualStudio.LanguageServer.Protocol.DocumentSymbol.Kind"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.RoslynDocumentSymbolParams">
            <summary>
            A parameter object that indicates whether the LSP client should use hierarchical symbols. Inherits from
            DocumentSymbolParams.
            </summary>
            <remarks>
            The LSP client does not support hierarchical document symbols and we can't contribute to client capabilities as
            the extension. This type is required in order to obtain a response of type DocumentSymbol[] for a document
            symbol request.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.WorkspaceSymbolsHandler">
            <summary>
            TODO - This must be moved to the MS.CA.LanguageServer.Protocol project once
            we no longer reference VS icon types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.Handler.ExportCSharpVisualBasicLspServiceFactoryAttribute">
            <summary>
            Defines an easy to use subclass for <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ExportLspServiceFactoryAttribute"/> with the roslyn languages contract name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.IClientLanguageServerManager">
            <summary>
            Manages sending requests or notifications to the client or server.
            Note - be extremely intentional about using a request or notification.  Use exactly what the LSP spec defines the method as.
            For example methods defined as requests even with no parameters or return value must be sent as requests regardless.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.LanguageServerProtocolResources">
            <summary>
            Stub type - replace with type generated from resx file when resources are needed in this assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspOptionsStorage.MaxCompletionListSize">
            <summary>
            This sets the max list size we will return in response to a completion request.
            If there are more than this many items, we will set the isIncomplete flag on the returned completion list.
            If set to negative value, we will always return the full list.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspOptionsStorage.LspUsingDevkitFeatures">
            <summary>
            This flag is turned on when the C# devkit is installed.
            This can cause certain LSP features to behave differently, for example we avoid returning test code lenses when devkit is running.
            </summary>
            <remarks>
            This flag is not user visible.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspOptionsStorage.LspEnableReferencesCodeLens">
            <summary>
            Flag indicating whether or not references should be returned in LSP codelens.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspOptionsStorage.LspEnableTestsCodeLens">
            <summary>
            Flag indicating whether or not test and debug code lens items should be returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.ExportLspServiceFactoryAttribute">
            <summary>
            Exports an <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspServiceFactory"/> that is used by LSP server instances
            to create new instances of the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspService"/> each time an LSP server is started.
            
            The services created by the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspServiceFactory"/> are disposed of by <see cref="T:Microsoft.CodeAnalysis.LanguageServer.LspServices"/>
            when the LSP server instance shuts down.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.ExportLspServiceFactoryAttribute.Type">
            <summary>
            The type of the service being exported.  Used during retrieval to find the matching service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.ExportLspServiceFactoryAttribute.ServerKind">
            <summary>
            The LSP server for which this service applies to.  If null, this service applies to any server
            with the matching contract name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.ExportLspServiceFactoryAttribute.IsStateless">
            <summary>
            Services MEF exported as <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspServiceFactory"/> are statefull as <see cref="T:Microsoft.CodeAnalysis.LanguageServer.LspServices"/>
            creates a new instance for each server instance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.ExportStatelessLspServiceAttribute">
            <summary>
            Defines an attribute to export an instance of <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspService"/> that is re-used across
            all server instances in the same mef container.  Services using this export attribute should not
            store any kind of server specific state in them.
            
            MEF will dispose of these services when the container is disposed of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.ExportStatelessLspServiceAttribute.Type">
            <summary>
            The type of the service being exported.  Used during retrieval to find the matching service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.ExportStatelessLspServiceAttribute.ServerKind">
            <summary>
            The LSP server for which this service applies to.  If null, this service applies to any server
            with the matching contract name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServer.ExportStatelessLspServiceAttribute.IsStateless">
            <summary>
            Services MEF exported as <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspService"/> must by definition be stateless as they are
            shared amongst all LSP server instances through restarts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.ILspServiceFactory.CreateILspService(Microsoft.CodeAnalysis.LanguageServer.LspServices,Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds)">
            <summary>
            Some LSP services need to know the client capabilities on construction or
            need to know about other <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ILspService"/> instances to be constructed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspServices._baseServices">
            <summary>
            A set of base services that apply to all roslyn lsp services.
            Unfortunately MEF doesn't provide a good way to export something for multiple contracts with metadata
            so these are manually created in <see cref="T:Microsoft.CodeAnalysis.LanguageServer.RoslynLanguageServer"/>.
            TODO - cleanup once https://github.com/dotnet/roslyn/issues/63555 is resolved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspServices._gate">
            <summary>
            Gates access to <see cref="F:Microsoft.CodeAnalysis.LanguageServer.LspServices._servicesToDispose"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.RoslynRequestExecutionQueue._cultureInfo">
            <summary>
            Serial access is guaranteed by the queue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.RoslynRequestExecutionQueue.GetCultureForRequest">
            <summary>
            Serial access is guaranteed by the queue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.RazorLspServer">
            <summary>
            Roslyn LSP server for razor c# requests.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.LiveShareLspServer">
            <summary>
            Roslyn LSP server for liveshare guests.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.AlwaysActiveVSLspServer">
            <summary>
            Roslyn LSP server always activated in VS.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.CSharpVisualBasicLspServer">
            <summary>
            Roslyn LSP server for non-VS use cases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.XamlLspServer">
            <summary>
            XAML LSP servers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.RoslynTypeScriptLspServer">
            <summary>
            LSP server for TypeScript
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.WellKnownLspServerKinds.Any">
            <summary>
            Flag representing any LSP server - used by <see cref="T:Microsoft.CodeAnalysis.LanguageServer.ExportLspServiceFactoryAttribute"/>
            to specify that something applies to any LSP server.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.ILspWorkspace">
            <summary>
            Interface to indicate that a workspace wants to customize what happens in the lsp server when lsp contents for a
            file are updated by an lsp client. In VS, for example, we have a non-mutating workspace.  The VS workspace itself is
            updated automatically with the real contents of buffers, and by tracking the running-doc-table.  Changes that come
            in through LSP do not impact this actual workspace.  Instead, the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager"/> creates an
            overlay, where it uses the <see cref="T:Microsoft.CodeAnalysis.Solution"/> snapshot from the VS workspace, but then forks it in any cases
            where it's view of the world may differ from LSP (which can happen as LSP is async, and so may represent a state of
            the world that is slightly different from what the VS workspace thinks it is.
            <para/>
            For hosts though where there is no external source of truth (for example, a server that might host roslyn directly,
            where all info comes from LSP), this enables LSP to 'push through' file changes directly to the to the workspace's
            model. That way, the workspace's solution is always in sync with what LSP thinks it is (at least for open
            documents).
            <para/>
            It is fine for external changes to happen to the contents of documents within the workspace (see <see
            cref="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.Document)"/>).  However, they will be overwritten by the <see
            cref="T:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager"/> for any changed documents it knows about (through <see
            cref="F:Microsoft.VisualStudio.LanguageServer.Protocol.Methods.TextDocumentDidChange"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.ILspWorkspace.UpdateTextIfPresentAsync(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="documentId"/> is currently within this workspace, then its text is updated to <paramref
            name="sourceText"/>.  Does nothing if the document is not present in the workspace (for example if something
            else removed it).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.LspMiscellaneousFilesWorkspace">
            <summary>
            Defines a default workspace for opened LSP files that are not found in any
            workspace registered by the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceRegistrationService"/>.
            If a document added here is subsequently found in a registered workspace, 
            the document is removed from this workspace.
            
            Future work for this workspace includes supporting basic metadata references (mscorlib, System dlls, etc),
            but that is dependent on having a x-plat mechanism for retrieving those references from the framework / sdk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspMiscellaneousFilesWorkspace.AddMiscellaneousDocument(System.Uri,Microsoft.CodeAnalysis.Text.SourceText,System.String,Microsoft.CommonLanguageServerProtocol.Framework.ILspLogger)">
            <summary>
            Takes in a file URI and text and creates a misc project and document for the file.
            
            Calls to this method and <see cref="M:Microsoft.CodeAnalysis.LanguageServer.LspMiscellaneousFilesWorkspace.TryRemoveMiscellaneousDocument(System.Uri)"/> are made
            from LSP text sync request handling which do not run concurrently.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspMiscellaneousFilesWorkspace.TryRemoveMiscellaneousDocument(System.Uri)">
            <summary>
            Removes a document with the matching file path from this workspace.
            
            Calls to this method and <see cref="M:Microsoft.CodeAnalysis.LanguageServer.LspMiscellaneousFilesWorkspace.AddMiscellaneousDocument(System.Uri,Microsoft.CodeAnalysis.Text.SourceText,System.String,Microsoft.CommonLanguageServerProtocol.Framework.ILspLogger)"/> are made
            from LSP text sync request handling which do not run concurrently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager">
            <summary>
            Manages the registered workspaces and corresponding LSP solutions for an LSP server.
            This type is tied to a particular server.
            </summary>
            <remarks>
            This type provides an LSP view of the registered workspace solutions so that all LSP requests operate
            on the state of the world that matches the LSP requests we've received.  
            
            This is done by storing the LSP text as provided by client didOpen/didClose/didChange requests.  When asked for a document we provide either
            <list type="bullet">
                <item> The exact workspace solution instance if all the LSP text matches what is currently in the workspace.</item>
                <item> A fork from the workspace current solution with the LSP text applied if the LSP text does not match.  This can happen since
                LSP text sync is asynchronous and not guaranteed to match the text in the workspace (though the majority of the time in VS it does).</item>
            </list>
            
            Doing the forking like this has a few nice properties.
            <list type="bullet">
              <item>99% of the time the VS workspace matches the LSP text.  In those cases we do 0 re-parsing, share compilations, versions, checksum calcs, etc.</item>
              <item>In the 1% of the time that we do not match, we can simply and easily compute a fork.</item>
              <item>The code is relatively straightforward</item>
            </list>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager._cachedLspSolutions">
            <summary>
            A cache from workspace to the last solution we returned for LSP.
            <para/> The forkedFromVersion is not null when the solution was created from a fork of the workspace with LSP
            text applied on top. It is null when LSP reuses the workspace solution (the LSP text matches the contents of the
            workspace).
            <para/> Access to this is guaranteed to be serial by the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager._trackedDocuments">
            <summary>
            Stores the current source text for each URI that is being tracked by LSP. Each time an LSP text sync
            notification comes in, this source text is updated to match. Used as the backing implementation for the <see
            cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.IDocumentChangeTracker"/>.
            <para/> Note that the text here is tracked regardless of whether or not we found a matching roslyn document for
            the URI.
            <para/> Access to this is guaranteed to be serial by the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.StartTrackingAsync(System.Uri,Microsoft.CodeAnalysis.Text.SourceText,System.String,System.Threading.CancellationToken)">
            <summary>
            Called by the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidOpenHandler"/> when a document is opened in LSP.
            
            <see cref="P:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidOpenHandler.MutatesSolutionState"/> is true which means this runs serially in the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.StopTrackingAsync(System.Uri,System.Threading.CancellationToken)">
            <summary>
            Called by the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidCloseHandler"/> when a document is closed in LSP.
            
            <see cref="P:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidCloseHandler.MutatesSolutionState"/> is true which means this runs serially in the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.UpdateTrackedDocument(System.Uri,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Called by the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidChangeHandler"/> when a document's text is updated in LSP.
            
            <see cref="P:Microsoft.CodeAnalysis.LanguageServer.Handler.DocumentChanges.DidChangeHandler.MutatesSolutionState"/> is true which means this runs serially in the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.GetLspSolutionInfoAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the LSP solution associated with the workspace with workspace kind <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.Host"/>.
            This is the solution used for LSP requests that pertain to the entire workspace, for example code search or
            workspace diagnostics.
            
            This is always called serially in the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/> when creating the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.GetLspDocumentInfoAsync(Microsoft.VisualStudio.LanguageServer.Protocol.TextDocumentIdentifier,System.Threading.CancellationToken)">
            <summary>
            Returns the LSP solution associated with the workspace with kind <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.Host"/>. This is the
            solution used for LSP requests that pertain to the entire workspace, for example code search or workspace
            diagnostics.
            
            This is always called serially in the <see cref="T:Microsoft.CommonLanguageServerProtocol.Framework.RequestExecutionQueue`1"/> when creating the <see cref="T:Microsoft.CodeAnalysis.LanguageServer.Handler.RequestContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.GetLspSolutionsAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the LSP view of all the registered workspaces' current solutions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.DoesAllTextMatchWorkspaceSolutionAsync(System.Collections.Immutable.ImmutableDictionary{System.Uri,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Document}},System.Threading.CancellationToken)">
            <summary>
            Given a set of documents from the workspace current solution, verify that the LSP text is the same as the document contents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceManager.GetDocumentsForUris(System.Collections.Immutable.ImmutableArray{System.Uri},Microsoft.CodeAnalysis.Solution)">
            <summary>
            Using the workspace's current solutions, find the matching documents in for each URI.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.LanguageServer.LspWorkspaceRegistrationService.LspSolutionChanged">
            <summary>
            Indicates whether the LSP solution has changed in a non-tracked document context.
            
            <b>IMPORTANT:</b> Implementations of this event handler should do as little synchronous work as possible since this will block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.DiagnosticSet">
            <summary>
            Indicates which code fixes are enabled for a Code Cleanup operation. Each code fix in the set is triggered by
            one or more diagnostic IDs, which could be provided by the compiler or an analyzer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.DiagnosticSet.IsAnyDiagnosticIdExplicitlyEnabled">
            <summary>
            Diagnostic set is enabled for all severities if it has been explicitly selected as part of the cleanup profile.
            If the diagnostic set has not been explicitly selected, but gets bulk included by selecting
            "Fix all warnings and errors set in EditorConfig", then we only include diagnostics with Warning Or Error severity.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.EnabledDiagnosticOptions">
            <summary>
            Indicates which features are enabled for a code cleanup operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.EnabledDiagnosticOptions.#ctor(System.Boolean,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.DiagnosticSet},Microsoft.CodeAnalysis.CodeCleanup.OrganizeUsingsSet)">
            <summary>
            Indicates which features are enabled for a code cleanup operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.OrganizeUsingsSet">
            <summary>
            Indicates which, if any, Organize Usings features are enabled for code cleanup.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixService.GetSuppressionFixer(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary> Looks explicitly for an <see cref="T:Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider"/>.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ICodeFixService.GetMostSevereFixAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,System.Threading.CancellationToken)">
            <summary>
            Similar to <see cref="M:Microsoft.CodeAnalysis.CodeFixes.ICodeFixService.StreamFixesAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,System.Func{System.String,System.IDisposable},System.Threading.CancellationToken)"/> except that instead of streaming all results, this ends with the
            first.  This will also attempt to return a fix for an error first, but will fall back to any fix if that
            does not succeed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DefaultDiagnosticAnalyzerService.DefaultDiagnosticIncrementalAnalyzer.GetDiagnosticsAsync(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Diagnostics.AnalysisKind,System.Threading.CancellationToken)">
            <summary>
            Get diagnostics for the given document.
            
            This is a simple API to get all diagnostics for the given document.
            
            The intended audience for this API is for ones that pefer simplicity over performance such as document that belong to misc project.
            this doesn't cache nor use cache for anything. it will re-caculate new diagnostics every time for the given document.
            it will not persist any data on disk nor use OOP to calculate the data.
            
            This should never be used when performance is a big concern. for such context, use much complex API from IDiagnosticAnalyzerService
            that provide all kinds of knobs/cache/persistency/OOP to get better perf over simplicity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerService.SynchronizeWithBuildAsync(Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData}},Roslyn.Utilities.TaskQueue,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Synchronize build errors with live error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.NoOpIncrementalAnalyzer.Priority">
            <summary>
            Set to a low priority so everything else runs first.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor">
            <summary>
            Executes analyzers on a document for computing local syntax/semantic/additional file diagnostics for a specific <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor.ComputeDiagnosticsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Threading.CancellationToken)">
            <summary>
            Return all local diagnostics (syntax, semantic) that belong to given document for the given analyzer by calculating them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor.CreateAnalyzerExceptionDiagnostic(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Exception)">
            <summary>
            Create a diagnostic for exception thrown by the given analyzer.
            </summary>
            <remarks>
            Keep this method in sync with "AnalyzerExecutor.CreateAnalyzerExceptionDiagnostic".
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor.IsAnalyzerEnabledForProject(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Options.IGlobalOptionService)">
            <summary>
            Return true if the given <paramref name="analyzer"/> is not suppressed for the given project.
            NOTE: This API is intended to be used only for performance optimization.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer">
            <summary>
            Diagnostic Analyzer Engine V2
            
            This one follows pattern compiler has set for diagnostic analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ActiveFileState">
            <summary>
            state that is responsible to hold onto local diagnostics data regarding active/opened files (depends on host)
            in memory.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData">
            <summary>
            Simple data holder for local diagnostics for an analyzer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.Version">
            <summary>
            Version of the diagnostic data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.LineCount">
            <summary>
            Number of lines in the document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.Items">
            <summary>
            Current data that matches the version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData.OldItems">
            <summary>
            Last set of data we broadcasted to outer world, or <see langword="default"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData">
            <summary>
            Data holder for all diagnostics for a project for an analyzer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.ProjectId">
            <summary>
            ProjectId of this data
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.Version">
            <summary>
            Version of the Items
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.Result">
            <summary>
            Current data that matches the version
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalysisData.OldResult">
            <summary>
            When present, holds onto last data we broadcasted to outer world.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetOrCreateCompilationWithAnalyzersAsync(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet},System.Threading.CancellationToken)">
            <summary>
            Return CompilationWithAnalyzer for given project with given stateSets
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.Priority">
            <summary>
            The highest priority (lowest value) amongst all incremental analyzers (others have priority 1).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.TryGetCachedDocumentAnalysisData(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet,Microsoft.CodeAnalysis.Diagnostics.AnalysisKind,Microsoft.CodeAnalysis.VersionStamp,Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope,Microsoft.CodeAnalysis.SolutionCrawler.CompilerDiagnosticsScope,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Threading.CancellationToken,System.Boolean@)">
            <summary>
            Return all cached local diagnostics (syntax, semantic) that belong to given document for the given StateSet (analyzer).
            Otherwise, return <code>null</code>.
            For the latter case, <paramref name="isAnalyzerSuppressed"/> indicates if the analyzer is suppressed
            for the given document/project. If suppressed, the caller does not need to compute the diagnostics for the given
            analyzer. Otherwise, diagnostics need to be computed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ComputeDocumentAnalysisDataAsync(Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisExecutor,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ActiveFileState,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Computes all local diagnostics (syntax, semantic) that belong to given document for the given StateSet (analyzer).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetProjectAnalysisDataAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Diagnostics.IdeAnalyzerOptions,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics that belong to given project for the given StateSets (analyzers) either from cache or by calculating them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ComputeDiagnosticsAsync(Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Calculate all diagnostics for a given project using analyzers referenced by the project and specified IDE analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer">
            <summary>
            This type performs incremental analysis in presence of edits to only a single member inside a document.
            For typing scenarios where we are continuously editing a method body, we can optimize the full
            document diagnostic computation by doing the following:
              1. Re-using all the old cached diagnostics outside the edited member node from a prior
                 document snapshot, but with updated diagnostic spans.
                 AND
              2. Replacing all the old diagnostics for the edited member node in a prior document snapshot
                 with the newly computed diagnostics for this member node in the latest document snaphot.
            If we are unable to perform this incremental diagnostics update, we fallback to computing
            the diagnostics for the entire document.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer._lastDocumentWithCachedDiagnostics">
            <summary>
            Weak reference to the last document snapshot for which full document diagnostics
            were computed and saved.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer.MemberSpans">
            <summary>
            Spans of member nodes for incremental analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.IncrementalMemberEditAnalyzer.MemberSpans.#ctor(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.VersionStamp,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Spans of member nodes for incremental analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalyzerReferenceChangedEventArgs">
            <summary>
            EventArgs for <see cref="E:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.ProjectAnalyzerReferenceChanged"/>
            
            this event args contains information such as <see cref="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectAnalyzerReferenceChangedEventArgs.Project"/> the <see cref="T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference"/> has changed
            and what <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> has changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState">
            <summary>
            State for diagnostics that belong to a project at given time.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState.GetAnalysisDataAsync(Microsoft.CodeAnalysis.Project,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics for the given project stored in this state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState.GetAnalysisDataAsync(Microsoft.CodeAnalysis.TextDocument,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all diagnostics for the given document stored in this state including non local diagnostics for this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.ProjectState.GetProjectAnalysisDataAsync(Microsoft.CodeAnalysis.Project,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Return all no location diagnostics for the given project stored in this state
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager">
            <summary>
            This is in charge of anything related to <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager._hostAnalyzerStateMap">
            <summary>
            Analyzers supplied by the host (IDE). These are built-in to the IDE, the compiler, or from an installed IDE extension (VSIX). 
            Maps language name to the analyzers and their state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager._projectAnalyzerStateMap">
            <summary>
            Analyzers referenced by the project via a PackageReference.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.ProjectAnalyzerReferenceChanged">
            <summary>
            This will be raised whenever <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager"/> finds <see cref="P:Microsoft.CodeAnalysis.Project.AnalyzerReferences"/> change
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetAllStateSets">
            <summary>
            Return all <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>.
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetStateSets(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>. 
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            Difference with <see cref="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetStateSets(Microsoft.CodeAnalysis.ProjectId)"/> is that 
            this will only return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s that have same language as <paramref name="project"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrUpdateStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>. 
            This will either return already created <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the specific snapshot of <see cref="T:Microsoft.CodeAnalysis.Project"/> or
            It will create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the <see cref="T:Microsoft.CodeAnalysis.Project"/> and update internal state.
            
            since this has a side-effect, this should never be called concurrently. and incremental analyzer (solution crawler) should guarantee that.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrCreateStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the given <see cref="T:Microsoft.CodeAnalysis.Project"/>. 
            This will either return already created <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the specific snapshot of <see cref="T:Microsoft.CodeAnalysis.Project"/> or
            It will create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s for the <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            Unlike <see cref="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrUpdateStateSets(Microsoft.CodeAnalysis.Project)"/>, this has no side effect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.GetOrCreateStateSet(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> for the given <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/> in the context of <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            This will either return already created <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> for the specific snapshot of <see cref="T:Microsoft.CodeAnalysis.Project"/> or
            It will create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> for the <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            This will not have any side effect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.CreateBuildOnlyProjectStateSet(Microsoft.CodeAnalysis.Project)">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/>s that are added as the given <see cref="T:Microsoft.CodeAnalysis.Project"/>'s AnalyzerReferences.
            This will never create new <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> but will return ones already created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.CreateProjectStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Creates a new project state sets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateManager.UpdateProjectStateSets(Microsoft.CodeAnalysis.Project)">
            <summary>
            Updates the map to the given project snapshot.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet">
            <summary>
            this contains all states regarding a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.LatestDiagnosticsForSpanGetter">
            <summary>
            Get diagnostics for given span either by using cache or calculating it on the spot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.LatestDiagnosticsForSpanGetter.TryAddCachedDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Diagnostics.AnalysisKind,Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.DocumentAnalysisData,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData},System.Threading.CancellationToken)">
            <summary>
            Returns <see langword="true"/> if we were able to add the cached diagnostics and we do not need to compute them fresh.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.GetStateSetsForFullSolutionAnalysis(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet},Microsoft.CodeAnalysis.Project)">
            <summary>
            Return list of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.EngineV2.DiagnosticIncrementalAnalyzer.StateSet"/> to be used for full solution analysis.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService">
            <summary>
            Aggregates events from various diagnostic sources.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.DiagnosticsUpdated">
            <summary>
            Event to get notified as new diagnostics are discovered by IDiagnosticUpdateSource
            
            Notifications for this event are serialized to preserve order.
            However, individual event notifications may occur on any thread.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.GetDiagnosticsAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Object,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get current diagnostics stored in IDiagnosticUpdateSource.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IDiagnosticService.GetDiagnosticBuckets(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Get current buckets storing our grouped diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.InternalDiagnosticsOptionsStorage.RazorDiagnosticMode">
            <summary>
            Diagnostic mode setting for Razor.  This should always be <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticMode.LspPull"/> as there is no push support in Razor.
            This option is only for passing to the diagnostics service and can be removed when we switch all of Roslyn to LSP pull.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.InternalDiagnosticsOptionsStorage.LiveShareDiagnosticMode">
            <summary>
            Diagnostic mode setting for Live Share.  This should always be <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticMode.LspPull"/> as there is no push support in Live Share.
            This option is only for passing to the diagnostics service and can be removed when we switch all of Roslyn to LSP pull.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindUsages.SimpleFindUsagesContext">
            <summary>
            Simple implementation of a <see cref="T:Microsoft.CodeAnalysis.FindUsages.FindUsagesContext"/> that just aggregates the results
            for consumers that just want the data once it is finally computed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.RazorLineFormattingOptionsStorage">
            <summary>
            Formatting options for Razor design-time documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.BackgroundAnalysisScopeOption">
            <summary>
            Option to turn configure background analysis scope for the current user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.SolutionBackgroundAnalysisScopeOption">
            <summary>
            Option to turn configure background analysis scope for the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.CompilerDiagnosticsScopeOption">
            <summary>
            Option to configure compiler diagnostics scope for the current user.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.LowMemoryForcedMinimalBackgroundAnalysis">
            <summary>
            Enables forced <see cref="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.Minimal"/> scope when low VM is detected to improve performance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.GetBackgroundAnalysisScope(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
             <summary>
             <para>Gets the effective background analysis scope for the current solution.</para>
            
             <para>Gets the solution-specific analysis scope set through
             <see cref="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.SolutionBackgroundAnalysisScopeOption"/>, or the default analysis scope if no solution-specific
             scope is set.</para>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.GetBackgroundCompilerAnalysisScope(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
             <summary>
             <para>Gets the effective background compiler analysis scope for the current solution.</para>
            
             <para>Gets the solution-specific analysis scope set through
             <see cref="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.SolutionBackgroundAnalysisScopeOption"/>, or the default compiler analysis scope if no
             solution-specific scope is set.</para>
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            Returns true if full solution analysis is enabled for the given
            <paramref name="analyzer"/> through options for the given <paramref name="language"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            Returns true if the entire solution will be analyzed in the background
            to compute up-to-date diagnostics for the error list.
            Note that the background analysis scope for compiler diagnostics and
            analyzers can be different. If you want to fetch individual values for
            whether or not full solution analysis is enabled for compiler diagnostics
            and analyzers, use the other overload
            <see cref="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String,System.Boolean@,System.Boolean@)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String,System.Boolean@,System.Boolean@)">
            <summary>
            Returns true if the entire solution will be analyzed in the background
            to compute up-to-date diagnostics for the error list.
            Note that the background analysis scope for compiler diagnostics and
            analyzers can be different. Full analysis is enabled if either
            <paramref name="compilerFullSolutionAnalysisEnabled"/> is true or
            <paramref name="analyzersFullSolutionAnalysisEnabled"/> is true.
            Full analysis is disabled only if both these flags are false.
            If you do not care about the individual full solution analysis values
            for compiler diagnostics and analyzers, use the other overload
            <see cref="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsFullSolutionAnalysisEnabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)"/>.
            </summary>
            <param name="globalOptions">Global options.</param>
            <param name="language">
            Language of the projects in the solution to analyze.
            </param>
            <param name="compilerFullSolutionAnalysisEnabled">
            Indicates if the compiler diagnostics need to be computed for the entire solution.
            </param>
            <param name="analyzersFullSolutionAnalysisEnabled">
            Indicates if analyzer diagnostics need to be computed for the entire solution.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptionsStorage.IsAnalysisDisabled(Microsoft.CodeAnalysis.Options.IGlobalOptionService,System.String)">
            <summary>
            Returns true if background analysis is completely disabled for
            both compiler diagnostics and analyzer diagnostics, i.e. the user
            does not want to see squiggles or error list entries for any diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptionsStorage.EnableOpeningSourceGeneratedFilesInWorkspace">
            <summary>
            This option allows the user to enable this. We are putting this behind a feature flag for now since we could have extensions
            surprised by this and we want some time to work through those issues.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedPredefinedSuggestedActionCategoryNames">
            <summary>
            Equivalent to PredefinedSuggestedActionCategoryNames, but in a location that
            can be used by both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet">
            <summary>
            Similar to SuggestedActionSet, but in a location that can be used
            by both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource">
            <summary>
            Provides mutual code action logic for both local and LSP scenarios
            via intermediate interface <see cref="T:Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.GetFilterAndOrderCodeFixesAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeFixes.ICodeFixService,Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,System.Func{System.String,System.IDisposable},System.Threading.CancellationToken)">
            <summary>
            Gets, filters, and orders code fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.OrganizeFixesAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection},System.Threading.CancellationToken)">
            <summary>
            Arrange fixes into groups based on the issue (diagnostic being fixed) and prioritize these groups.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.GroupFixesAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection},System.Collections.Generic.IDictionary{System.Tuple{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority,System.Nullable{Microsoft.CodeAnalysis.CodeActions.CodeActionPriority}},System.Collections.Generic.IList{Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction}},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Tuple{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority,System.Nullable{Microsoft.CodeAnalysis.CodeActions.CodeActionPriority}}},System.Threading.CancellationToken)">
            <summary>
            Groups fixes by the diagnostic being addressed by each fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.PrioritizeFixGroups(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Immutable.ImmutableDictionary{System.Tuple{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority,System.Nullable{Microsoft.CodeAnalysis.CodeActions.CodeActionPriority}},System.Collections.Generic.IList{Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction}},System.Collections.Immutable.ImmutableArray{System.Tuple{Microsoft.CodeAnalysis.Diagnostics.DiagnosticData,Microsoft.CodeAnalysis.CodeActions.CodeActionPriority,System.Nullable{Microsoft.CodeAnalysis.CodeActions.CodeActionPriority}}},Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Return prioritized set of fix groups such that fix group for suppression always show up at the bottom of the list.
            </summary>
            <remarks>
            Fix groups are returned in priority order determined based on <see cref="T:Microsoft.CodeAnalysis.ExtensionOrderAttribute"/>.
            Priority for all <see cref="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet"/>s containing fixes is set to <see
            cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Default"/> by default. The only exception is the case where a <see
            cref="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet"/> only contains suppression fixes - the priority of such <see
            cref="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet"/>s is set to <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Lowest"/> so that suppression
            fixes always show up last after all other fixes (and refactorings) for the selected line of code.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.GetFilterAndOrderCodeRefactoringsAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService,Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Nullable{Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority},Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,System.Func{System.String,System.IDisposable},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets, filters, and orders code refactorings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.OrganizeRefactoringsAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring,System.Threading.CancellationToken)">
            <summary>
            Arrange refactorings into groups.
            </summary>
            <remarks>
            Refactorings are returned in priority order determined based on <see cref="T:Microsoft.CodeAnalysis.ExtensionOrderAttribute"/>.
            Priority for all <see cref="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet"/>s containing refactorings is set to
            <see cref="F:Microsoft.CodeAnalysis.CodeActions.CodeActionPriority.Low"/> and should show up after fixes but before
            suppression fixes in the light bulb menu.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.FilterAndOrderActionSets(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionSet},System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},System.Int32)">
            <summary>
            Filters and orders the code fix sets and code refactoring sets amongst each other.
            Should be called with the results from <see cref="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.GetFilterAndOrderCodeFixesAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeFixes.ICodeFixService,Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider,Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,System.Func{System.String,System.IDisposable},System.Threading.CancellationToken)"/>
            and <see cref="M:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionsSource.GetFilterAndOrderCodeRefactoringsAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService,Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.TextSpan,System.Nullable{Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority},Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider,System.Func{System.String,System.IDisposable},System.Boolean,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.ICodeFixSuggestedAction">
            <summary>
            Common interface used by both local Roslyn and LSP to implement
            their specific versions of CodeFixSuggestedAction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.ICodeRefactoringSuggestedAction">
            <summary>
            Common interface used by both local Roslyn and LSP to implement
            their specific versions of CodeRefactoringSuggestedAction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.IFixAllCodeFixSuggestedAction">
            <summary>
            Common interface used by both local Roslyn and LSP to implement
            their specific versions of FixAllCodeFixSuggestedAction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActions.IFixAllCodeRefactoringSuggestedAction">
            <summary>
            Common interface used by both local Roslyn and LSP to implement
            their specific versions of FixAllCodeRefactoringSuggestedAction.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.IUnifiedSuggestedAction">
            <summary>
            Similar to ISuggestedAction, but in a location that can be used by both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedCodeFixSuggestedAction">
            <summary>
            Similar to CodeFixSuggestionAction, but in a location that can be used by
            both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedCodeRefactoringSuggestedAction">
            <summary>
            Similar to CodeRefactoringSuggestedAction, but in a location that can be used by
            both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedFixAllCodeFixSuggestedAction">
            <summary>
            Similar to FixAllCodeFixSuggestedAction, but in a location that can be used by
            both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedFixAllCodeRefactoringSuggestedAction">
            <summary>
            Similar to FixAllCodeRefactoringSuggestedAction, but in a location that can be used by
            both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedAction">
            <summary>
            Similar to SuggestedAction, but in a location that can be used by
            both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.UnifiedSuggestions.UnifiedSuggestedActionWithNestedActions">
            <summary>
            Similar to SuggestedActionWithNestedActions, but in a location that can be used by
            both local Roslyn and LSP.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.LanguageServer.Protocol.MapCodeParams">
            <summary>
            LSP Params for textDocument/mapCode calls.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.LanguageServer.Protocol.MapCodeParams.#ctor(Microsoft.VisualStudio.LanguageServer.Protocol.MapCodeMapping[],Microsoft.VisualStudio.LanguageServer.Protocol.WorkspaceEdit)">
            <summary>
            LSP Params for textDocument/mapCode calls.
            </summary>
        </member>
    </members>
</doc>
